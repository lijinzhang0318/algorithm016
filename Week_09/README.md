#### 不同路径2

- 状态定义

&emsp;用 dp[i][j] 表示走到格子(i, j)的不同方法数

- 状态转移方程

&emsp; ① 当格子(i, j)上存在障碍物时，dp[i][j] = 0；

&emsp; ② 当格子(i, j)上无障碍物时，dp[i][j] = dp[i−1,j]+dp[i,j−1]

#### 字符串匹配算法

##### 暴力法

&emsp;朴素法，时间复杂度 O(mn)

##### Rabin-Karp 算法

> 算法思想：
<br>1.假设子串的长度为M(pat)，目标字符串的长度为N(txt)
<br>2.计算字串的hash值 hash_pat
<br>3.计算目标字符串txt中每个长度为M的子串的hash值（共需要计算N-M+1次）
<br>4.比较hash值：如果hash值不同，字符串必然不匹配；如果hash值相同，还需要使用朴素算法再次判断

##### KMP 算法

> 算法思想：
<br>&emsp;当子串与目标字符串不匹配时，其实已经知道了前面已经匹配成功那一部分的字符（包括子串与目标字符串），设法利用这个已知信息，不要把“搜索位置”移回已经比较的位置，继续把它向后移，这样就提高了效率。
